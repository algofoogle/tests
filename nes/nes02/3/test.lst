ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : test.s
Current file: test.s

000000r 1               ; This example builds on the skeleton .nes file structure defined in nes02/2,
000000r 1               ; by introducing a couple of CHR ROM tiles, and some minimal functioning PRG code
000000r 1               ; (in this case, just an endless loop).
000000r 1               
000000r 1               ; =============================== iNES HEADER ==========================================
000000r 1               
000000r 1               ; First we create the iNES header, which we will assume can be said to start at $0000:
000000r 1               .org $0000
000000  1               
000000  1               ; ...and the following iNES header defines a .nes file which is expected to have the following
000000  1               ; binary layout:
000000  1               ;	1.	0x0000-0x000F:	Header (16 bytes).
000000  1               ;	2.	0x0010-0x400F:	PRG ROM (one PRG chunk; 16KiB).
000000  1               ;	3.	0x4010-0x600F:	CHR ROM (one CHR chunk; 8KiB).
000000  1               
000000  1  4E 45 53 1A  .byt "NES",$1A			; Header magic.
000004  1  01           .byt 1 					; Specify that we have only 1 x PRG ROM chunk (16KiB).
000005  1  01           .byt 1 					; ...and only 1 x CHR ROM chunk (8KiB).
000006  1  00           .byt %00000000			; 'Flags 6' bits.
000007  1  00           .byt %00000000			; 'Flags 7' bits.
000008  1  00           .byt 0 					; We have 0 x 8KiB chunks of PRG RAM, though apparently this actually
000009  1               						; infers that we have 1 x 8KiB chunk.
000009  1               						; See http://wiki.nesdev.com/w/index.php/PRG_RAM_circuit for more info.
000009  1  00           .byt %00000000 			; 'Flags 9' bits.
00000A  1  00           .byt %00000000			; 'Flags 10' bits.
00000B  1  00 00 00 00  .res (16-*), $00 		; Pad the rest of the header out to 16, with $00 as the filler.
00000F  1  00           
000010  1               
000010  1               ; =============================== PRG ROM ==========================================
000010  1               
000010  1               ; PRG ROM size (defined above) is 16KiB, mapped to $C000-$FFFF.
000010  1               .org $C000
00C000  1               
00C000  1               ; ISR (Interrupt Service Routine) for the NMI:
00C000  1               nmi_isr:
00C000  1               	; Handle NMI here.
00C000  1  40           	rti
00C001  1               
00C001  1               ; ISR for the IRQ/BRK interrupt:
00C001  1               irq_isr:
00C001  1               	; Handle IRQ/BRK here.
00C001  1  40           	rti
00C002  1               
00C002  1               ; MAIN PROGRAM START: The 'reset' address (referenced by the Interrupt Vectors table, later on).
00C002  1               reset:
00C002  1               	; Make a simple noise by selecting a square wave voice and
00C002  1               	; defining the periods for which the waveform is high and low.
00C002  1               	; This sound is then emitted endlessly, until otherwise instructed,
00C002  1               	; regardless of what the CPU is doing (which in this case, will
00C002  1               	; be executing an endless loop at 'forever').
00C002  1  A9 01        	lda #$01 		; Square 1
00C004  1  8D 15 40     	sta $4015
00C007  1  A9 F0        	lda #$F0		; period (LSByte)
00C009  1  8D 02 40     	sta $4002
00C00C  1  A9 01        	lda #$01		; period (MSByte)
00C00E  1  8D 03 40     	sta $4003
00C011  1  A9 BF        	lda #$bf		; volume
00C013  1  8D 00 40     	sta $4000
00C016  1               
00C016  1               forever:
00C016  1  EA           	nop
00C017  1  4C 16 C0     	jmp forever		; Loop endlessly.
00C01A  1               
00C01A  1               ; ---------------= Interrupt Vectors =--------------------
00C01A  1               
00C01A  1               ; Pad out the PRG ROM to $FFF4, which is sort of where the 6502 interrupt vector table starts
00C01A  1               ; (See: http://en.wikipedia.org/wiki/Interrupts_in_65xx_processors)
00C01A  1  00 00 00 00  .res ($FFF4-*), $00
00C01E  1  00 00 00 00  
00C022  1  00 00 00 00  
00FFF4  1               
00FFF4  1               ; We are now at $FFF4...
00FFF4  1               ; NOTE: The labels here are irrelevant, really, but just make it clear what each
00FFF4  1               ; vector actually is:
00FFF4  1               cop_vector:			; $FFF4
00FFF4  1  00 00        	.word $0000 	; (Unused)
00FFF6  1               brk_vector:			; $FFF6
00FFF6  1  00 00        	.word $0000 	; (Unused; actually a 65C816 vector)
00FFF8  1               abort_vector:		; $FFF8
00FFF8  1  00 00        	.word $0000 	; (Unused)
00FFFA  1               nmi_vector:			; $FFFA
00FFFA  1  00 C0        	.word nmi_isr	; Address of the NMI ISR, defined near the start of the main PRG code in this case.
00FFFC  1               reset_vector:		; $FFFC
00FFFC  1  02 C0        	.word reset		; Address of where to go after a reset; i.e. main program start.
00FFFE  1               irq_vector:			; $FFFE
00FFFE  1  01 C0        	.word irq_isr	; Address of the IRQ/BRK ISR.
010000  1               
010000  1               
010000  1               
010000  1               ; =============================== CHR ROM ==========================================
010000  1               
010000  1               ; NOTE: Instead of putting the CHR ROM into this source file, you could just have it as
010000  1               ; a separate binary file (e.g. created with 'chromp') and then 'cat' it onto your .nes file,
010000  1               ; or otherwise include its raw binary data here with .incbin.
010000  1               
010000  1               ; The PPU (Picture Processing Unit) in the NES has its own address space
010000  1               ; (http://wiki.nesdev.com/w/index.php/PPU), in which $0000-$0FFF is "Pattern Table 0"
010000  1               ; (or the lower CHR bank), and $1000-$1FFF is "Pattern Table 1" (or the upper CHR bank),
010000  1               ; for a total of 8KiB of "pattern data".
010000  1               ; The cartridge typically maps this to CHR ROM or CHR RAM, and can map it to more than
010000  1               ; one bank by use of a 'mapper'.
010000  1               ; See http://wiki.nesdev.com/w/index.php/PPU_memory_map for more info.
010000  1               
010000  1               ; Pattern Table 0:
010000  1               .org $0000
000000  1               
000000  1  81           .byt %10000001
000001  1  42           .byt %01000010
000002  1  24           .byt %00100100
000003  1  18           .byt %00011000
000004  1  18           .byt %00011000
000005  1  24           .byt %00100100
000006  1  42           .byt %01000010
000007  1  81           .byt %10000001
000008  1               
000008  1  10           .byt %00010000
000009  1  10           .byt %00010000
00000A  1  10           .byt %00010000
00000B  1  FF           .byt %11111111
00000C  1  10           .byt %00010000
00000D  1  10           .byt %00010000
00000E  1  10           .byt %00010000
00000F  1  10           .byt %00010000
000010  1               
000010  1               ; Pad out to 4KiB:
000010  1  00 00 00 00  .res ($1000-*), $00
000014  1  00 00 00 00  
000018  1  00 00 00 00  
001000  1               
001000  1               ; Pattern Table 1:
001000  1               	;;;;;;;;;;;;;;
001000  1               	;; PATTERN TABLE 0 DATA GOES HERE
001000  1               	;;;;;;;;;;;;;;
001000  1               
001000  1               ; Pad out to 8KiB:
001000  1  00 00 00 00  .res ($2000-*), $00
001004  1  00 00 00 00  
001008  1  00 00 00 00  
001000  1               
