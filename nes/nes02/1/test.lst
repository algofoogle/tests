ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : test.s
Current file: test.s

000000r 1               ; This file does nothing more than toy with various ca65 control commands
000000r 1               ; (see: http://www.cc65.org/doc/ca65-11.html#control-commands),
000000r 1               ; and prove that we can produce a binary (i.e. output/test.prg) with highly
000000r 1               ; predictable content if we want to.
000000r 1               ;
000000r 1               ; Compile with:
000000r 1               ;   ./bb
000000r 1               ; Which is roughly equivalent to:
000000r 1               ;   # Compile to object file:
000000r 1               ;   ca65 test.s -o test output/test.o
000000r 1               ;   # Link to bare binary:
000000r 1               ;   ld65 output/test.o -o output/test.prg -m output/map.txt -t none
000000r 1               ; View contents with:
000000r 1               ;   hexdump -C output/test.prg
000000r 1               
000000r 1               ; By default, we start off with an 'address' of $0200, at the very start of the file.
000000r 1               ; This is because, by default, we're in the system-defined 'CODE' segment which,
000000r 1               ; by default, must be set to start at the $0200 address. This was confirmed by
000000r 1               ; examining the output/map.txt file generated by ld65, as described above.
000000r 1               ; Note that, by putting "-l" into the ca65 line, you can generate a listing
000000r 1               ; file which shows exactly what bytes were generated (and at what relative addresses)
000000r 1               ; by the assembly process. This reveals, for instance that the addresses (up
000000r 1               ; until the first ".org" command I have below) are 'relocatable' (i.e. they have
000000r 1               ; an 'r' at the end of them in the listing), so that the final address of the CODE
000000r 1               ; segment is not necessarily set in stone until the linking stage.
000000r 1               
000000r 1               ; The very first byte of the file will be an exclamation point (ASCII 0x21):
000000r 1  21           .byt $21													; 21
000001r 1               ; Now our 'address' is at $0201
000001r 1               
000001r 1               ; Now store a string (again, followed by an exclamation point):
000001r 1  48 65 6C 6C  .byt "Hello, World", $21									; 48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 21
000005r 1  6F 2C 20 57  
000009r 1  6F 72 6C 64  
00000Er 1               ; That was 13 bytes, putting our address now at $020E. Let's create a label
00000Er 1               ; that will effectively 'be' that address...
00000Er 1               
00000Er 1               first_label:			; Now equiv to $020E
00000Er 1               
00000Er 1               ; Store a word, in this case $89AB, which will turn into two bytes:
00000Er 1               ; $AB and $89 (i.e. little-endian):
00000Er 1  AB 89        .word $89AB													; AB 89
000010r 1               ; Address: $0210
000010r 1               
000010r 1               ; Store a word which is equal to the address of first_label:
000010r 1  rr rr        .word first_label											; 0E 02
000012r 1               ; Address: $0212
000012r 1               
000012r 1               ; Store a word which is the CURRENT address:
000012r 1  rr rr        .word (*)													; 12 02
000014r 1               ; Address: $0214
000014r 1               
000014r 1               ; Store a word which is an expression derrived from the current address:
000014r 1  1A 00        .word (* - first_label + 20)	; $0214-$020E+$0014=$001A	; 1A 00
000016r 1               ; Address: $0216
000016r 1               
000016r 1               ; NOW let's mess with our "origin" (i.e. address) a bit, first by putting it
000016r 1               ; back to $0000:
000016r 1               .org $0000
000000  1               ; Address: $0000
000000  1               
000000  1               ; ...such that storing a word containing the current address will now get $0000:
000000  1  00 00        .word *														; 00 00
000002  1               ; Address: $0002
000002  1               
000002  1               ; Then advance to $CDEF:
000002  1               .org $CDEF
00CDEF  1               ; Address: $CDEF
00CDEF  1               
00CDEF  1               ; This causes the 'e' character in strings ($65) to be mapped to 'E' instead ($45)
00CDEF  1               .charmap 'e', $45
00CDEF  1               
00CDEF  1               ; ...then put a string (this time with a CR & LF, which are evidently NOT supported with "\r\n"):
00CDEF  1  48 45 6C 6C  .byt 'H', "ello", $0D, $0A										; 48 45 6c 6c 6f 0D 0A
00CDF3  1  6F 0D 0A     
00CDF6  1               ; Address: $CDF6
00CDF6  1               
00CDF6  1               ; Now capture that address:
00CDF6  1               second_label:
00CDF6  1               
00CDF6  1               ; Then offset again...
00CDF6  1               .org $1000
001000  1               ; Address: $1000
001000  1               
001000  1               ; ...then store the address before the offset:
001000  1  F6 CD        .word second_label											; F6 CD
001002  1               ; Address: $1002
001002  1               
001002  1               ; ...and finally store the CURRENT address again, but this time as a 'double-byte' (which is big-endian):
001002  1  10 02        .dbyt *														; 10 02
001004  1               ; Address: $1004
001004  1               
001004  1               third_label:
001004  1               ; We can confirm that we definitely have reached that address now, by using an .assert:
001004  1               .assert * = $1004, error, "third_label is NOT at $1004"
001004  1               
001004  1               ; Now store a double-word (little-endian):
001004  1  78 56 34 12  .dword $12345678											; 78 56 34 12
001008  1               ; Address: $1008
001008  1               
001008  1               ; Now 'reserve' (fill) 10 bytes with $EE:
001008  1  EE EE EE EE  .res 10, $EE 												; EE EE EE EE EE EE EE EE EE EE
00100C  1  EE EE EE EE  
001010  1  EE EE        
001012  1               ; Address: $1012
001012  1               
